---
title: 'SQL Query Library'
sidebarTitle: "SQL Query Library"
description: "Copy/paste BigQuery SQL templates to answer common questions using SourceMedium tables"
icon: "code"
---

### Overview

Use these queries as starting points for analysis in BigQuery. Replace `your_project` with your BigQuery project ID (e.g., `sm-yourcompany`) and `your-sm_store_id` with your store identifier.

<Tip>
**Query Standards:**
- Always include `is_order_sm_valid = TRUE` for order-based analyses
- Use `your_project.sm_transformed_v2.*` for standard tables
- Use `your_project.sm_experimental.*` for MTA tables
</Tip>

If you're not sure which table to use, start with: [`obt_orders`](/data-activation/data-tables/sm_transformed_v2/obt_orders) and [`obt_order_lines`](/data-activation/data-tables/sm_transformed_v2/obt_order_lines).

---

## AI Analyst query templates (v0)

These templates are derived from real AI Analyst evaluation questions and normalized for reuse in BigQuery.

<Info>
Most examples default to the last 30 days for performance and “current state” analysis. Adjust the timeframe and add `sm_store_id` scoping when needed.
</Info>

### Marketing & Ads

<AccordionGroup>
  <Accordion title="Q011 — Average CAC (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=CAC=ad_spend/new_customer_count | grain=sm_channel | scope=all_channels
    WITH channel_rollup AS (
      SELECT
        sm_channel,
        SUM(ABS(ad_spend)) AS ad_spend,
        SUM(new_customer_count) AS new_customers
      FROM `your_project.sm_transformed_v2.rpt_executive_summary_daily`
      WHERE date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
        AND ad_spend IS NOT NULL
        AND new_customer_count IS NOT NULL
      GROUP BY 1
    ),
    overall AS (
      SELECT
        '(all_channels)' AS sm_channel,
        SUM(ABS(ad_spend)) AS ad_spend,
        SUM(new_customer_count) AS new_customers
      FROM `your_project.sm_transformed_v2.rpt_executive_summary_daily`
      WHERE date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
        AND ad_spend IS NOT NULL
        AND new_customer_count IS NOT NULL
    )
    SELECT
      sm_channel,
      ad_spend,
      new_customers,
      SAFE_DIVIDE(ad_spend, NULLIF(new_customers, 0)) AS cac
    FROM channel_rollup
    WHERE ad_spend > 0

    UNION ALL

    SELECT
      sm_channel,
      ad_spend,
      new_customers,
      SAFE_DIVIDE(ad_spend, NULLIF(new_customers, 0)) AS cac
    FROM overall
    WHERE ad_spend > 0
    ORDER BY cac ASC;
    ```
  </Accordion>

  <Accordion title="Q001 — Highest ROAS by platform + campaign type (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=ROAS=platform_reported_revenue/ad_spend | grain=platform+campaign_type | scope=all_stores
    SELECT
      sm_store_id,
      source_system AS platform,
      ad_campaign_type AS campaign_type,
      SUM(ad_platform_reported_revenue) AS platform_reported_revenue,
      SUM(ad_spend) AS ad_spend,
      SAFE_DIVIDE(SUM(ad_platform_reported_revenue), NULLIF(SUM(ad_spend), 0)) AS roas
    FROM `your_project.sm_transformed_v2.rpt_ad_performance_daily`
    WHERE date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
      AND ad_spend > 0
    GROUP BY 1, 2, 3
    ORDER BY roas DESC
    LIMIT 20;
    ```
  </Accordion>

  <Accordion title="Q081 — ROAS trends over time (monthly, last 6 months)">
    ```sql
    -- Assumptions: timeframe=last_6_months | metric=ROAS=platform_reported_revenue/ad_spend | grain=month+platform | scope=all_stores
    WITH monthly AS (
      SELECT
        DATE_TRUNC(date, MONTH) AS month_start,
        source_system AS platform,
        SUM(ad_platform_reported_revenue) AS platform_reported_revenue,
        SUM(ad_spend) AS ad_spend
      FROM `your_project.sm_transformed_v2.rpt_ad_performance_daily`
      WHERE date >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 6 MONTH)
        AND date < DATE_ADD(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 1 MONTH)
        AND ad_spend > 0
      GROUP BY 1, 2
    )
    SELECT
      platform,
      month_start,
      ad_spend,
      platform_reported_revenue,
      SAFE_DIVIDE(platform_reported_revenue, NULLIF(ad_spend, 0)) AS roas
    FROM monthly
    ORDER BY platform, month_start;
    ```
  </Accordion>
</AccordionGroup>

### Customers & Retention

<AccordionGroup>
  <Accordion title="Q022 — First-time vs repeat orders (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=orders+customers+net_revenue | grain=first_vs_repeat | scope=valid_orders_only
    SELECT
      CASE WHEN order_index = 1 THEN 'first_order' ELSE 'repeat_order' END AS order_type,
      COUNT(DISTINCT sm_order_key) AS orders,
      COUNT(DISTINCT sm_customer_key) AS customers,
      SUM(order_net_revenue) AS order_net_revenue
    FROM `your_project.sm_transformed_v2.obt_orders`
    WHERE is_order_sm_valid = TRUE
      AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
    GROUP BY 1
    ORDER BY orders DESC;
    ```
  </Accordion>

  <Accordion title="Q021 — Which source/mediums drive repeat purchases? (cohorted on first order in last 12 months)">
    ```sql
    -- Assumptions: timeframe=first_orders_last_12_months | metric=repeat_rate=customers_with_2+_orders/customers | grain=first_order_source_medium | scope=valid_orders_only
    WITH valid_orders AS (
      SELECT
        sm_customer_key,
        sm_order_key,
        order_processed_at_local_datetime,
        COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') AS source_medium,
        ROW_NUMBER() OVER (
          PARTITION BY sm_customer_key
          ORDER BY order_processed_at_local_datetime
        ) AS rn
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND sm_customer_key IS NOT NULL
    ),
    customer_summary AS (
      SELECT
        sm_customer_key,
        MAX(CASE WHEN rn = 1 THEN source_medium END) AS first_order_source_medium,
        MIN(CASE WHEN rn = 1 THEN DATE(order_processed_at_local_datetime) END) AS first_order_date,
        COUNT(DISTINCT sm_order_key) AS valid_order_count
      FROM valid_orders
      GROUP BY 1
    )
    SELECT
      first_order_source_medium AS source_medium,
      COUNT(*) AS customers,
      COUNTIF(valid_order_count >= 2) AS repeat_customers,
      SAFE_DIVIDE(COUNTIF(valid_order_count >= 2), COUNT(*)) AS repeat_rate,
      AVG(valid_order_count - 1) AS avg_subsequent_orders
    FROM customer_summary
    WHERE first_order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 365 DAY)
    GROUP BY 1
    HAVING customers >= 100
    ORDER BY repeat_rate DESC
    LIMIT 25;
    ```
  </Accordion>

  <Accordion title="Q003 — New vs repeat customer ratio trend (weekly, YTD)">
    ```sql
    -- Assumptions: timeframe=year_to_date | metric=new_to_repeat_ratio=new_customer_count/repeat_customer_count | grain=week | scope=all_channels
    WITH weekly AS (
      SELECT
        DATE_TRUNC(date, WEEK(MONDAY)) AS week_start,
        SUM(new_customer_count) AS new_customers,
        SUM(repeat_customer_count) AS repeat_customers
      FROM `your_project.sm_transformed_v2.rpt_executive_summary_daily`
      WHERE date >= DATE_TRUNC(CURRENT_DATE(), YEAR)
      GROUP BY 1
    )
    SELECT
      week_start,
      new_customers,
      repeat_customers,
      SAFE_DIVIDE(new_customers, NULLIF(repeat_customers, 0)) AS new_to_repeat_ratio
    FROM weekly
    ORDER BY week_start;
    ```
  </Accordion>

  <Accordion title="Q082 — Customer acquisition trend (monthly new customers, last 12 months)">
    ```sql
    -- Assumptions: timeframe=last_12_months | metric=new_customers | grain=month | scope=all_channels
    WITH monthly AS (
      SELECT
        DATE_TRUNC(date, MONTH) AS month_start,
        SUM(new_customer_count) AS new_customers,
        SUM(new_customer_order_count) AS new_customer_orders,
        SUM(new_customer_order_net_revenue) AS new_customer_order_net_revenue
      FROM `your_project.sm_transformed_v2.rpt_executive_summary_daily`
      WHERE date >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 12 MONTH)
      GROUP BY 1
    )
    SELECT
      month_start,
      new_customers,
      new_customer_orders,
      new_customer_order_net_revenue,
      SAFE_DIVIDE(new_customer_order_net_revenue, NULLIF(new_customer_orders, 0)) AS new_customer_aov
    FROM monthly
    ORDER BY month_start;
    ```
  </Accordion>
</AccordionGroup>

### Products

<AccordionGroup>
  <Accordion title="Q119 — Top 10 products by net revenue (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=net_revenue=SUM(order_line_net_revenue) | grain=sku | scope=valid_orders_only
    SELECT
      sku,
      ANY_VALUE(product_title) AS product_title,
      SUM(order_line_net_revenue) AS order_line_net_revenue,
      SUM(order_line_quantity) AS units_sold,
      COUNT(DISTINCT sm_order_key) AS orders
    FROM `your_project.sm_transformed_v2.obt_order_lines`
    WHERE is_order_sm_valid = TRUE
      AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
      AND sku IS NOT NULL
      AND NOT REGEXP_CONTAINS(product_title, r'(?i)(shipping protection|not a product|service fee|processing fee)')
    GROUP BY 1
    ORDER BY order_line_net_revenue DESC
    LIMIT 10;
    ```
  </Accordion>

  <Accordion title="Q083 — Top products by units sold (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=units_sold=SUM(order_line_quantity) | grain=sku | scope=valid_orders_only
    SELECT
      sku,
      ANY_VALUE(product_title) AS product_title,
      SUM(order_line_quantity) AS units_sold,
      SUM(order_line_net_revenue) AS order_line_net_revenue,
      COUNT(DISTINCT sm_order_key) AS orders
    FROM `your_project.sm_transformed_v2.obt_order_lines`
    WHERE is_order_sm_valid = TRUE
      AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
      AND sku IS NOT NULL
      AND NOT REGEXP_CONTAINS(product_title, r'(?i)(shipping protection|not a product|service fee|processing fee)')
    GROUP BY 1
    ORDER BY units_sold DESC
    LIMIT 20;
    ```
  </Accordion>

  <Accordion title="Q017 — Products most common with new customers (first valid orders, last 90 days)">
    ```sql
    -- Assumptions: timeframe=first_valid_orders_last_90_days | metric=units_sold=SUM(order_line_quantity) | grain=product_title | scope=new_customers_valid_orders_only
    WITH first_valid_orders AS (
      SELECT
        sm_order_key
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND sm_valid_order_index = 1
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY)
    )
    SELECT
      ol.product_title,
      SUM(ol.order_line_quantity) AS units_sold,
      COUNT(DISTINCT ol.sm_order_key) AS orders,
      COUNT(DISTINCT ol.sku) AS skus
    FROM `your_project.sm_transformed_v2.obt_order_lines` ol
    INNER JOIN first_valid_orders fvo
      ON ol.sm_order_key = fvo.sm_order_key
    WHERE ol.is_order_sm_valid = TRUE
      AND ol.sku IS NOT NULL
      AND NOT REGEXP_CONTAINS(ol.product_title, r'(?i)(shipping protection|not a product|service fee|processing fee)')
    GROUP BY 1
    ORDER BY units_sold DESC
    LIMIT 25;
    ```
  </Accordion>
</AccordionGroup>

### Orders & revenue

<AccordionGroup>
  <Accordion title="Q060 — Average order value (AOV) by marketing channel (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=AOV=SUM(order_net_revenue)/orders | grain=sm_utm_source_medium | scope=valid_orders_only
    WITH base AS (
      SELECT
        COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') AS marketing_channel,
        sm_order_key,
        sm_customer_key,
        order_net_revenue
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
    )
    SELECT
      marketing_channel,
      COUNT(DISTINCT sm_order_key) AS orders,
      COUNT(DISTINCT sm_customer_key) AS customers,
      SUM(order_net_revenue) AS order_net_revenue,
      SAFE_DIVIDE(SUM(order_net_revenue), NULLIF(COUNT(DISTINCT sm_order_key), 0)) AS aov
    FROM base
    GROUP BY 1
    HAVING orders >= 50
    ORDER BY aov DESC
    LIMIT 50;
    ```
  </Accordion>

  <Accordion title="Q023 — Revenue in the last 30 days from customers who have ever had a subscription">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=net_revenue=SUM(order_net_revenue) | grain=overall | scope=customers_with_any_subscription_history
    WITH subscription_customers AS (
      SELECT DISTINCT
        sm_customer_key
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND is_subscription_order = TRUE
        AND sm_customer_key IS NOT NULL
    ),
    last_30_valid_orders AS (
      SELECT
        sm_order_key,
        sm_customer_key,
        order_net_revenue
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
        AND sm_customer_key IS NOT NULL
    )
    SELECT
      SUM(CASE WHEN sc.sm_customer_key IS NOT NULL THEN o.order_net_revenue ELSE 0 END) AS revenue_from_customers_with_subscription_history,
      SUM(o.order_net_revenue) AS total_revenue_last_30_days,
      SAFE_DIVIDE(
        SUM(CASE WHEN sc.sm_customer_key IS NOT NULL THEN o.order_net_revenue ELSE 0 END),
        NULLIF(SUM(o.order_net_revenue), 0)
      ) AS pct_of_revenue_from_subscription_history_customers
    FROM last_30_valid_orders o
    LEFT JOIN subscription_customers sc
      ON o.sm_customer_key = sc.sm_customer_key;
    ```
  </Accordion>

  <Accordion title="Q062 — Refund rate by marketing channel (last 90 days)">
    ```sql
    -- Assumptions: timeframe=last_90_days | metric=refund_rate | grain=sm_utm_source_medium | scope=valid_orders_only
    WITH base AS (
      SELECT
        COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') AS marketing_channel,
        order_total_refunds,
        order_net_revenue_before_refunds,
        sm_order_key
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY)
    )
    SELECT
      marketing_channel,
      COUNT(DISTINCT sm_order_key) AS orders,
      COUNTIF(ABS(order_total_refunds) > 0) AS refunded_orders,
      SAFE_DIVIDE(COUNTIF(ABS(order_total_refunds) > 0), NULLIF(COUNT(DISTINCT sm_order_key), 0)) AS refund_rate_orders,
      ABS(SUM(order_total_refunds)) AS refund_amount,
      SUM(order_net_revenue_before_refunds) AS revenue_before_refunds,
      SAFE_DIVIDE(ABS(SUM(order_total_refunds)), NULLIF(SUM(order_net_revenue_before_refunds), 0)) AS refund_rate_revenue
    FROM base
    GROUP BY 1
    HAVING orders >= 50
    ORDER BY refund_rate_revenue DESC
    LIMIT 50;
    ```
  </Accordion>

  <Accordion title="Q115 — Distribution of orders and revenue by sales channel (last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=orders+net_revenue+share | grain=sm_channel | scope=valid_orders_only
    SELECT
      sm_channel,
      COUNT(*) AS orders,
      SUM(order_net_revenue) AS order_net_revenue,
      SAFE_DIVIDE(COUNT(*), NULLIF(SUM(COUNT(*)) OVER (), 0)) AS pct_orders,
      SAFE_DIVIDE(SUM(order_net_revenue), NULLIF(SUM(SUM(order_net_revenue)) OVER (), 0)) AS pct_revenue
    FROM `your_project.sm_transformed_v2.obt_orders`
    WHERE is_order_sm_valid = TRUE
      AND order_cancelled_at IS NULL
      AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
      AND sm_channel IS NOT NULL
    GROUP BY 1
    ORDER BY orders DESC;
    ```
  </Accordion>
</AccordionGroup>

## LTV & Retention (advanced)

These are higher-effort templates that require careful cohort definitions and denominators.

<Info>
If you use the cohort LTV table (`rpt_cohort_ltv_by_first_valid_purchase_attribute_no_product_filters`):
- Always filter **one** cohort dimension (e.g., `acquisition_order_filter_dimension = 'source/medium'`)
- Always include `sm_order_line_type = 'all_orders'` unless you explicitly want a subset
</Info>

### Cohort table discovery

```sql
-- Assumptions: timeframe=all_time | metric=discovery | grain=acquisition_order_filter_dimension | scope=cohort_table_only
SELECT DISTINCT
  acquisition_order_filter_dimension
FROM `your_project.sm_transformed_v2.rpt_cohort_ltv_by_first_valid_purchase_attribute_no_product_filters`
ORDER BY 1;
```

<AccordionGroup>
  <Accordion title="Q029 — 3m/6m retention + 6m LTV by acquisition source/medium (last 12 cohort months)">
    ```sql
    -- Assumptions: timeframe=last_12_cohort_months | metric=retention_pct+ltv_6m | grain=source_medium | scope=cohort_table_all_orders
    WITH pivoted AS (
      SELECT
        acquisition_order_filter_dimension_value AS source_medium,
        cohort_month,
        ANY_VALUE(cohort_size) AS cohort_size,
        MAX(IF(months_since_first_order = 3, customer_count, NULL)) AS customers_m3,
        MAX(IF(months_since_first_order = 6, customer_count, NULL)) AS customers_m6,
        MAX(IF(months_since_first_order = 6, cumulative_order_net_revenue, NULL)) AS cumulative_order_net_revenue_m6
      FROM `your_project.sm_transformed_v2.rpt_cohort_ltv_by_first_valid_purchase_attribute_no_product_filters`
      WHERE acquisition_order_filter_dimension = 'source/medium'
        AND sm_order_line_type = 'all_orders'
        AND cohort_month >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 12 MONTH)
        AND months_since_first_order IN (3, 6)
      GROUP BY 1, 2
    )
    SELECT
      source_medium,
      SUM(cohort_size) AS cohort_customers,
      SAFE_DIVIDE(SUM(customers_m3), NULLIF(SUM(cohort_size), 0)) AS retention_m3,
      SAFE_DIVIDE(SUM(customers_m6), NULLIF(SUM(cohort_size), 0)) AS retention_m6,
      SAFE_DIVIDE(SUM(cumulative_order_net_revenue_m6), NULLIF(SUM(cohort_size), 0)) AS ltv_net_per_customer_m6
    FROM pivoted
    GROUP BY 1
    HAVING cohort_customers >= 200
    ORDER BY retention_m6 DESC
    LIMIT 25;
    ```
  </Accordion>

  <Accordion title="Q041 — Top discount-code cohorts by 6m retention + 12m LTV (last 12 cohort months)">
    ```sql
    -- Assumptions: timeframe=last_12_cohort_months | metric=retention_m6+ltv_12m | grain=discount_code | scope=cohort_table_all_orders
    WITH pivoted AS (
      SELECT
        acquisition_order_filter_dimension_value AS discount_code,
        cohort_month,
        ANY_VALUE(cohort_size) AS cohort_size,
        MAX(IF(months_since_first_order = 6, customer_count, NULL)) AS customers_m6,
        MAX(IF(months_since_first_order = 12, cumulative_order_net_revenue, NULL)) AS cumulative_order_net_revenue_m12
      FROM `your_project.sm_transformed_v2.rpt_cohort_ltv_by_first_valid_purchase_attribute_no_product_filters`
      WHERE acquisition_order_filter_dimension = 'discount_code'
        AND sm_order_line_type = 'all_orders'
        AND cohort_month >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 12 MONTH)
        AND months_since_first_order IN (6, 12)
        AND acquisition_order_filter_dimension_value IS NOT NULL
        AND acquisition_order_filter_dimension_value != ''
      GROUP BY 1, 2
    ),
    aggregated AS (
      SELECT
        discount_code,
        SUM(cohort_size) AS cohort_customers,
        SAFE_DIVIDE(SUM(customers_m6), NULLIF(SUM(cohort_size), 0)) AS retention_m6,
        SAFE_DIVIDE(SUM(cumulative_order_net_revenue_m12), NULLIF(SUM(cohort_size), 0)) AS ltv_net_per_customer_m12
      FROM pivoted
      GROUP BY 1
      HAVING cohort_customers >= 100
    )
    SELECT
      discount_code,
      cohort_customers,
      retention_m6,
      ltv_net_per_customer_m12
    FROM aggregated
    ORDER BY ltv_net_per_customer_m12 DESC
    LIMIT 25;
    ```
  </Accordion>

  <Accordion title="Q019 — Subscription vs one-time cohorts: 6m retention + 12m LTV (last 12 cohort months)">
    ```sql
    -- Assumptions: timeframe=last_12_cohort_months | metric=retention_m6+ltv_12m | grain=first_order_type | scope=cohort_table_all_orders
    WITH pivoted AS (
      SELECT
        acquisition_order_filter_dimension_value AS first_order_type,
        cohort_month,
        ANY_VALUE(cohort_size) AS cohort_size,
        MAX(IF(months_since_first_order = 6, customer_count, NULL)) AS customers_m6,
        MAX(IF(months_since_first_order = 12, cumulative_order_net_revenue, NULL)) AS cumulative_order_net_revenue_m12
      FROM `your_project.sm_transformed_v2.rpt_cohort_ltv_by_first_valid_purchase_attribute_no_product_filters`
      WHERE acquisition_order_filter_dimension = 'order_type_(sub_vs._one_time)'
        AND sm_order_line_type = 'all_orders'
        AND cohort_month >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), MONTH), INTERVAL 12 MONTH)
        AND months_since_first_order IN (6, 12)
      GROUP BY 1, 2
    )
    SELECT
      first_order_type,
      SUM(cohort_size) AS cohort_customers,
      SAFE_DIVIDE(SUM(customers_m6), NULLIF(SUM(cohort_size), 0)) AS retention_m6,
      SAFE_DIVIDE(SUM(cumulative_order_net_revenue_m12), NULLIF(SUM(cohort_size), 0)) AS ltv_net_per_customer_m12
    FROM pivoted
    GROUP BY 1
    HAVING cohort_customers >= 50
    ORDER BY ltv_net_per_customer_m12 DESC;
    ```
  </Accordion>

  <Accordion title="Q007 — Which initial products lead to the highest 90‑day LTV? (primary first‑order SKU, last 12 months)">
    ```sql
    -- Assumptions: timeframe=first_valid_orders_last_12_months | metric=90d_LTV=SUM(order_net_revenue_90d) | grain=primary_first_sku | scope=valid_orders_only
    WITH first_valid_orders AS (
      SELECT
        sm_customer_key,
        sm_order_key,
        order_processed_at_local_datetime AS first_order_at_local_datetime
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND sm_customer_key IS NOT NULL
        AND sm_valid_order_index = 1
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 365 DAY)
    ),
    first_order_primary_sku AS (
      SELECT
        fo.sm_customer_key,
        ol.sku,
        ANY_VALUE(ol.product_title) AS product_title,
        SUM(ol.order_line_net_revenue) AS first_order_sku_net_revenue
      FROM first_valid_orders fo
      INNER JOIN `your_project.sm_transformed_v2.obt_order_lines` ol
        ON ol.sm_order_key = fo.sm_order_key
      WHERE ol.is_order_sm_valid = TRUE
        AND ol.sku IS NOT NULL
        AND NOT REGEXP_CONTAINS(ol.product_title, r'(?i)(shipping protection|not a product|service fee|processing fee)')
      GROUP BY 1, 2
      QUALIFY ROW_NUMBER() OVER (
        PARTITION BY fo.sm_customer_key
        ORDER BY first_order_sku_net_revenue DESC
      ) = 1
    ),
    customer_90d_ltv AS (
      SELECT
        fo.sm_customer_key,
        SUM(o.order_net_revenue) AS ltv_90d
      FROM first_valid_orders fo
      INNER JOIN `your_project.sm_transformed_v2.obt_orders` o
        ON o.sm_customer_key = fo.sm_customer_key
      WHERE o.is_order_sm_valid = TRUE
        AND o.order_cancelled_at IS NULL
        AND o.order_processed_at_local_datetime >= fo.first_order_at_local_datetime
        AND o.order_processed_at_local_datetime < DATETIME_ADD(fo.first_order_at_local_datetime, INTERVAL 90 DAY)
      GROUP BY 1
    )
    SELECT
      pos.sku,
      pos.product_title,
      COUNT(*) AS customers,
      AVG(ltv_90d) AS avg_ltv_90d,
      SUM(ltv_90d) AS total_ltv_90d
    FROM first_order_primary_sku pos
    INNER JOIN customer_90d_ltv ltv
      ON pos.sm_customer_key = ltv.sm_customer_key
    GROUP BY 1, 2
    HAVING customers >= 20
    ORDER BY avg_ltv_90d DESC
    LIMIT 25;
    ```
  </Accordion>

  <Accordion title="Q018 — Typical time between orders for non-subscription customers (last 12 months)">
    ```sql
    -- Assumptions: timeframe=last_12_months | metric=days_between_orders_distribution | grain=days_between_orders | scope=non_subscription_customers_only
    WITH subscription_customers AS (
      SELECT DISTINCT
        sm_customer_key
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND is_subscription_order = TRUE
        AND sm_customer_key IS NOT NULL
    ),
    non_subscription_orders AS (
      SELECT
        sm_customer_key,
        DATE(order_processed_at_local_datetime) AS order_date
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND sm_customer_key IS NOT NULL
        AND sm_customer_key NOT IN (SELECT sm_customer_key FROM subscription_customers)
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 365 DAY)
    ),
    per_customer_gaps AS (
      SELECT
        sm_customer_key,
        order_date,
        DATE_DIFF(
          order_date,
          LAG(order_date) OVER (PARTITION BY sm_customer_key ORDER BY order_date),
          DAY
        ) AS days_since_prior_order
      FROM non_subscription_orders
    )
    SELECT
      days_since_prior_order,
      COUNT(*) AS repeat_order_pairs
    FROM per_customer_gaps
    WHERE days_since_prior_order IS NOT NULL
      AND days_since_prior_order BETWEEN 1 AND 365
    GROUP BY 1
    ORDER BY days_since_prior_order;
    ```
  </Accordion>
</AccordionGroup>

## Attribution & Data Health (diagnostics)

These templates help you assess attribution coverage and basic data health before doing deeper analysis.

If you want table-level freshness/coverage metadata, start with: [`dim_data_dictionary`](/data-activation/data-tables/sm_metadata/dim_data_dictionary).

<AccordionGroup>
  <Accordion title="DQ01 — Which tables are stale or missing data? (last known data date)">
    ```sql
    -- Assumptions: timeframe=all_time | metric=table_freshness | grain=dataset+table | scope=sm_metadata
    SELECT
      dataset_name,
      table_name,
      MAX(CAST(table_has_data AS INT64)) > 0 AS table_has_data,
      MAX(CAST(table_has_fresh_data_14d AS INT64)) > 0 AS table_has_fresh_data_14d,
      MAX(table_last_data_date) AS table_last_data_date,
      ANY_VALUE(table_description) AS table_description
    FROM `your_project.sm_metadata.dim_data_dictionary`
    WHERE dataset_name IN ('sm_transformed_v2', 'sm_experimental')
      AND dataset_name IS NOT NULL
      AND table_name IS NOT NULL
    GROUP BY 1, 2
    ORDER BY table_has_fresh_data_14d ASC, table_has_data ASC, table_last_data_date ASC, dataset_name, table_name
    LIMIT 200;
    ```
  </Accordion>

  <Accordion title="DQ02 — Attribution column coverage on orders (UTMs, discount codes, zero-party, landing/referrer)">
    ```sql
    -- Assumptions: timeframe=all_time | metric=column_coverage | grain=column | scope=sm_metadata_obt_orders
    WITH cols AS (
      SELECT 'sm_utm_source' AS column_name UNION ALL
      SELECT 'sm_utm_medium' UNION ALL
      SELECT 'sm_utm_source_medium' UNION ALL
      SELECT 'sm_zero_party_attribution_source' UNION ALL
      SELECT 'order_discount_codes_csv' UNION ALL
      SELECT 'sm_order_landing_page' UNION ALL
      SELECT 'sm_order_referrer_domain'
    )
    SELECT
      d.table_name,
      d.column_name,
      ROUND(100 - d.column_null_percentage, 1) AS non_null_pct,
      d.column_distinct_count,
      (
        SELECT STRING_AGG(
          CONCAT(v.value, ' (', FORMAT('%.1f', v.pct), '%)'),
          ', '
          ORDER BY v.pct DESC
          LIMIT 8
        )
        FROM UNNEST(IFNULL(d.categorical_value_distribution, [])) AS v
        WHERE v.value IS NOT NULL AND v.pct IS NOT NULL
      ) AS top_values
    FROM `your_project.sm_metadata.dim_data_dictionary` d
    INNER JOIN cols c
      ON d.column_name = c.column_name
    WHERE d.dataset_name = 'sm_transformed_v2'
      AND d.table_name = 'obt_orders'
    ORDER BY non_null_pct DESC, d.column_distinct_count DESC, d.column_name;
    ```
  </Accordion>

  <Accordion title="DQ03 — Orders by source/medium (UTM coverage + direct/missing share, last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=orders+net_revenue+utm_coverage | grain=sm_utm_source_medium | scope=valid_orders_only
    WITH base AS (
      SELECT
        COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') AS source_medium,
        sm_order_key,
        order_net_revenue
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
    ),
    agg AS (
      SELECT
        source_medium,
        COUNT(DISTINCT sm_order_key) AS orders,
        SUM(order_net_revenue) AS order_net_revenue
      FROM base
      GROUP BY 1
    ),
    totals AS (
      SELECT
        COUNT(DISTINCT sm_order_key) AS total_orders,
        SUM(order_net_revenue) AS total_revenue,
        COUNTIF(source_medium != '(none) / (none)') AS orders_with_utm_source_medium
      FROM base
    )
    SELECT
      a.source_medium,
      a.orders,
      a.order_net_revenue,
      SAFE_DIVIDE(a.orders, NULLIF(t.total_orders, 0)) AS pct_orders,
      SAFE_DIVIDE(a.order_net_revenue, NULLIF(t.total_revenue, 0)) AS pct_revenue,
      SAFE_DIVIDE(t.orders_with_utm_source_medium, NULLIF(t.total_orders, 0)) AS overall_utm_coverage_orders
    FROM agg a
    CROSS JOIN totals t
    ORDER BY a.order_net_revenue DESC
    LIMIT 50;
    ```
  </Accordion>

  <Accordion title="DQ04 — When UTMs are missing, what other attribution signals exist? (last 90 days)">
    ```sql
    -- Assumptions: timeframe=last_90_days | metric=fallback_coverage | grain=overall | scope=valid_orders_only_missing_utms
    WITH missing_utms AS (
      SELECT
        sm_order_key,
        order_net_revenue,
        sm_zero_party_attribution_source,
        order_discount_codes_csv,
        sm_order_landing_page,
        sm_order_referrer_domain
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY)
        AND COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') = '(none) / (none)'
    )
    SELECT
      COUNT(DISTINCT sm_order_key) AS orders_missing_utms,
      SUM(order_net_revenue) AS order_net_revenue_missing_utms,
      COUNTIF(sm_zero_party_attribution_source IS NOT NULL AND TRIM(sm_zero_party_attribution_source) != '') AS orders_with_zero_party,
      SAFE_DIVIDE(
        COUNTIF(sm_zero_party_attribution_source IS NOT NULL AND TRIM(sm_zero_party_attribution_source) != ''),
        NULLIF(COUNT(DISTINCT sm_order_key), 0)
      ) AS pct_with_zero_party,
      COUNTIF(order_discount_codes_csv IS NOT NULL AND TRIM(order_discount_codes_csv) != '') AS orders_with_discount_code,
      SAFE_DIVIDE(
        COUNTIF(order_discount_codes_csv IS NOT NULL AND TRIM(order_discount_codes_csv) != ''),
        NULLIF(COUNT(DISTINCT sm_order_key), 0)
      ) AS pct_with_discount_code,
      COUNTIF(sm_order_landing_page IS NOT NULL AND TRIM(sm_order_landing_page) != '') AS orders_with_landing_page,
      SAFE_DIVIDE(
        COUNTIF(sm_order_landing_page IS NOT NULL AND TRIM(sm_order_landing_page) != ''),
        NULLIF(COUNT(DISTINCT sm_order_key), 0)
      ) AS pct_with_landing_page,
      COUNTIF(sm_order_referrer_domain IS NOT NULL AND TRIM(sm_order_referrer_domain) != '') AS orders_with_referrer_domain,
      SAFE_DIVIDE(
        COUNTIF(sm_order_referrer_domain IS NOT NULL AND TRIM(sm_order_referrer_domain) != ''),
        NULLIF(COUNT(DISTINCT sm_order_key), 0)
      ) AS pct_with_referrer_domain
    FROM missing_utms;
    ```
  </Accordion>

  <Accordion title="DQ05 — Top referrer domains for orders missing UTMs (last 90 days)">
    ```sql
    -- Assumptions: timeframe=last_90_days | metric=orders+net_revenue | grain=referrer_domain | scope=valid_orders_only_missing_utms
    WITH base AS (
      SELECT
        COALESCE(NULLIF(LOWER(TRIM(sm_order_referrer_domain)), ''), '(none)') AS referrer_domain,
        sm_order_key,
        order_net_revenue
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY)
        AND COALESCE(NULLIF(LOWER(TRIM(sm_utm_source_medium)), ''), '(none) / (none)') = '(none) / (none)'
    )
    SELECT
      referrer_domain,
      COUNT(DISTINCT sm_order_key) AS orders,
      SUM(order_net_revenue) AS order_net_revenue
    FROM base
    GROUP BY 1
    HAVING orders >= 25
    ORDER BY order_net_revenue DESC
    LIMIT 50;
    ```
  </Accordion>

  <Accordion title="DQ06 — Key join-key completeness (customers + SKU coverage, last 30 days)">
    ```sql
    -- Assumptions: timeframe=last_30_days | metric=null_rate_checks | grain=overall | scope=valid_orders_only
    WITH orders AS (
      SELECT
        COUNT(*) AS orders_total,
        COUNTIF(sm_customer_key IS NULL) AS orders_missing_customer_key
      FROM `your_project.sm_transformed_v2.obt_orders`
      WHERE is_order_sm_valid = TRUE
        AND order_cancelled_at IS NULL
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
    ),
    lines AS (
      SELECT
        COUNT(*) AS lines_total,
        COUNTIF(sku IS NULL OR TRIM(sku) = '' OR sku = 'Missing SKU') AS lines_missing_sku
      FROM `your_project.sm_transformed_v2.obt_order_lines`
      WHERE is_order_sm_valid = TRUE
        AND DATE(order_processed_at_local_datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
    )
    SELECT
      orders_total,
      orders_missing_customer_key,
      SAFE_DIVIDE(orders_missing_customer_key, NULLIF(orders_total, 0)) AS pct_orders_missing_customer_key,
      lines_total,
      lines_missing_sku,
      SAFE_DIVIDE(lines_missing_sku, NULLIF(lines_total, 0)) AS pct_lines_missing_sku
    FROM orders
    CROSS JOIN lines;
    ```
  </Accordion>
</AccordionGroup>

## Product Insights
<AccordionGroup>
    <Accordion title='Most commonly ordered product combinations'>
        ```sql
        -- Assumptions: timeframe=all_time | metric=order_frequency | grain=product_combination | scope=valid_orders_only
        WITH RECURSIVE product_combos AS (
            -- Anchor: Start with individual products per order
            SELECT
                ol.sm_store_id,
                ol.sm_order_key,
                1 AS combo_length,
                CONCAT(ol.product_title, ' - ', ol.product_variant_title) AS combo,
                CONCAT(ol.product_title, ' - ', ol.product_variant_title) AS last_item
            FROM `your_project.sm_transformed_v2.obt_order_lines` AS ol
            WHERE ol.sm_store_id = 'your-sm_store_id'
              AND ol.is_order_sm_valid = TRUE
              AND ol.sku IS NOT NULL
              AND NOT REGEXP_CONTAINS(ol.product_title, r'(?i)(shipping protection|not a product|service fee|processing fee|order specific)')

            UNION ALL

            -- Recursive: Build combinations up to 5 products
            SELECT
                ol.sm_store_id,
                ol.sm_order_key,
                pc.combo_length + 1,
                CONCAT(pc.combo, ', ', CONCAT(ol.product_title, ' - ', ol.product_variant_title)),
                CONCAT(ol.product_title, ' - ', ol.product_variant_title)
            FROM product_combos AS pc
            INNER JOIN `your_project.sm_transformed_v2.obt_order_lines` AS ol
                ON ol.sm_order_key = pc.sm_order_key
                AND CONCAT(ol.product_title, ' - ', ol.product_variant_title) > pc.last_item
            WHERE pc.combo_length < 5
              AND ol.is_order_sm_valid = TRUE
              AND ol.sku IS NOT NULL
              AND NOT REGEXP_CONTAINS(ol.product_title, r'(?i)(shipping protection|not a product|service fee|processing fee|order specific)')
        )

        SELECT
            combo AS product_combinations,
            COUNT(DISTINCT sm_order_key) AS order_frequency,
            combo_length AS num_products
        FROM product_combos
        WHERE combo_length >= 2
        GROUP BY combo, combo_length
        HAVING order_frequency >= 100
        ORDER BY order_frequency DESC, combo ASC
        LIMIT 100;
        ```

    </Accordion>
</AccordionGroup>

## More recipes

We regularly add new recipes. If there’s a query you’d like added (subscription churn, cohort LTV curves, creative performance, etc.), reach out to your SourceMedium team and include the business question and the table(s) you’re using.
